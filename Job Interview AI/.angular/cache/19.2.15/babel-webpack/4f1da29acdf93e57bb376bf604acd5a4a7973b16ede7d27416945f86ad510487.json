{"ast":null,"code":"import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform, getSupportedInputTypes } from '@angular/cdk/platform';\nimport { AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, NgZone, Renderer2, isSignal, effect, booleanAttribute, Directive, Input, NgModule } from '@angular/core';\nimport { _IdGenerator } from '@angular/cdk/a11y';\nimport { NgControl, Validators, NgForm, FormGroupDirective } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { M as MAT_INPUT_VALUE_ACCESSOR } from './input-value-accessor-D1GvPuqO.mjs';\nimport { h as MAT_FORM_FIELD, k as MatFormFieldControl } from './form-field-DqPi4knt.mjs';\nexport { b as MatError, j as MatFormField, c as MatHint, M as MatLabel, e as MatPrefix, g as MatSuffix } from './form-field-DqPi4knt.mjs';\nimport { E as ErrorStateMatcher } from './error-options-Dm2JJUbF.mjs';\nimport { _ as _ErrorStateTracker } from './error-state-Dtb1IHM-.mjs';\nimport { M as MatFormFieldModule } from './module-BXZhw7pQ.mjs';\nimport { M as MatCommonModule } from './common-module-WayjW0Pb.mjs';\nimport '@angular/cdk/bidi';\nimport '@angular/common';\nimport 'rxjs/operators';\nimport '@angular/cdk/observers/private';\nimport '@angular/cdk/observers';\n\n/** @docs-private */\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\n/** Injection token that can be used to provide the default options for the input. */\nconst MAT_INPUT_CONFIG = /*#__PURE__*/new InjectionToken('MAT_INPUT_CONFIG');\nlet MatInput = /*#__PURE__*/(() => {\n  class MatInput {\n    _elementRef = inject(ElementRef);\n    _platform = inject(Platform);\n    ngControl = inject(NgControl, {\n      optional: true,\n      self: true\n    });\n    _autofillMonitor = inject(AutofillMonitor);\n    _ngZone = inject(NgZone);\n    _formField = inject(MAT_FORM_FIELD, {\n      optional: true\n    });\n    _renderer = inject(Renderer2);\n    _uid = inject(_IdGenerator).getId('mat-input-');\n    _previousNativeValue;\n    _inputValueAccessor;\n    _signalBasedValueAccessor;\n    _previousPlaceholder;\n    _errorStateTracker;\n    _config = inject(MAT_INPUT_CONFIG, {\n      optional: true\n    });\n    _cleanupIosKeyup;\n    _cleanupWebkitWheel;\n    /** `aria-describedby` IDs assigned by the form field. */\n    _formFieldDescribedBy;\n    /** Whether the component is being rendered on the server. */\n    _isServer;\n    /** Whether the component is a native html select. */\n    _isNativeSelect;\n    /** Whether the component is a textarea. */\n    _isTextarea;\n    /** Whether the input is inside of a form field. */\n    _isInFormField;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    focused = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    stateChanges = new Subject();\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    controlType = 'mat-input';\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    autofilled = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n      // Browsers may not fire the blur event if the input is disabled too quickly.\n      // Reset from here to ensure that the element doesn't become stuck.\n      if (this.focused) {\n        this.focused = false;\n        this.stateChanges.next();\n      }\n    }\n    _disabled = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get id() {\n      return this._id;\n    }\n    set id(value) {\n      this._id = value || this._uid;\n    }\n    _id;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    placeholder;\n    /**\n     * Name of the input.\n     * @docs-private\n     */\n    name;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get required() {\n      return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n    }\n    set required(value) {\n      this._required = coerceBooleanProperty(value);\n    }\n    _required;\n    /** Input type of the element. */\n    get type() {\n      return this._type;\n    }\n    set type(value) {\n      const prevType = this._type;\n      this._type = value || 'text';\n      this._validateType();\n      // When using Angular inputs, developers are no longer able to set the properties on the native\n      // input element. To ensure that bindings for `type` work, we need to sync the setter\n      // with the native property. Textarea elements don't support the type property or attribute.\n      if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n        this._elementRef.nativeElement.type = this._type;\n      }\n      if (this._type !== prevType) {\n        this._ensureWheelDefaultBehavior();\n      }\n    }\n    _type = 'text';\n    /** An object used to control when error messages are shown. */\n    get errorStateMatcher() {\n      return this._errorStateTracker.matcher;\n    }\n    set errorStateMatcher(value) {\n      this._errorStateTracker.matcher = value;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    userAriaDescribedBy;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get value() {\n      return this._signalBasedValueAccessor ? this._signalBasedValueAccessor.value() : this._inputValueAccessor.value;\n    }\n    set value(value) {\n      if (value !== this.value) {\n        if (this._signalBasedValueAccessor) {\n          this._signalBasedValueAccessor.value.set(value);\n        } else {\n          this._inputValueAccessor.value = value;\n        }\n        this.stateChanges.next();\n      }\n    }\n    /** Whether the element is readonly. */\n    get readonly() {\n      return this._readonly;\n    }\n    set readonly(value) {\n      this._readonly = coerceBooleanProperty(value);\n    }\n    _readonly = false;\n    /** Whether the input should remain interactive when it is disabled. */\n    disabledInteractive;\n    /** Whether the input is in an error state. */\n    get errorState() {\n      return this._errorStateTracker.errorState;\n    }\n    set errorState(value) {\n      this._errorStateTracker.errorState = value;\n    }\n    _neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(t => getSupportedInputTypes().has(t));\n    constructor() {\n      const parentForm = inject(NgForm, {\n        optional: true\n      });\n      const parentFormGroup = inject(FormGroupDirective, {\n        optional: true\n      });\n      const defaultErrorStateMatcher = inject(ErrorStateMatcher);\n      const accessor = inject(MAT_INPUT_VALUE_ACCESSOR, {\n        optional: true,\n        self: true\n      });\n      const element = this._elementRef.nativeElement;\n      const nodeName = element.nodeName.toLowerCase();\n      if (accessor) {\n        if (isSignal(accessor.value)) {\n          this._signalBasedValueAccessor = accessor;\n        } else {\n          this._inputValueAccessor = accessor;\n        }\n      } else {\n        // If no input value accessor was explicitly specified, use the element as the input value\n        // accessor.\n        this._inputValueAccessor = element;\n      }\n      this._previousNativeValue = this.value;\n      // Force setter to be called in case id was not specified.\n      this.id = this.id;\n      // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n      // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n      // exists on iOS, we only bother to install the listener on iOS.\n      if (this._platform.IOS) {\n        this._ngZone.runOutsideAngular(() => {\n          this._cleanupIosKeyup = this._renderer.listen(element, 'keyup', this._iOSKeyupListener);\n        });\n      }\n      this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, this.ngControl, parentFormGroup, parentForm, this.stateChanges);\n      this._isServer = !this._platform.isBrowser;\n      this._isNativeSelect = nodeName === 'select';\n      this._isTextarea = nodeName === 'textarea';\n      this._isInFormField = !!this._formField;\n      this.disabledInteractive = this._config?.disabledInteractive || false;\n      if (this._isNativeSelect) {\n        this.controlType = element.multiple ? 'mat-native-select-multiple' : 'mat-native-select';\n      }\n      if (this._signalBasedValueAccessor) {\n        effect(() => {\n          // Read the value so the effect can register the dependency.\n          this._signalBasedValueAccessor.value();\n          this.stateChanges.next();\n        });\n      }\n    }\n    ngAfterViewInit() {\n      if (this._platform.isBrowser) {\n        this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n          this.autofilled = event.isAutofilled;\n          this.stateChanges.next();\n        });\n      }\n    }\n    ngOnChanges() {\n      this.stateChanges.next();\n    }\n    ngOnDestroy() {\n      this.stateChanges.complete();\n      if (this._platform.isBrowser) {\n        this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n      }\n      this._cleanupIosKeyup?.();\n      this._cleanupWebkitWheel?.();\n    }\n    ngDoCheck() {\n      if (this.ngControl) {\n        // We need to re-evaluate this on every change detection cycle, because there are some\n        // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n        // that whatever logic is in here has to be super lean or we risk destroying the performance.\n        this.updateErrorState();\n        // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n        // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n        // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n        // disabled.\n        if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n          this.disabled = this.ngControl.disabled;\n          this.stateChanges.next();\n        }\n      }\n      // We need to dirty-check the native element's value, because there are some cases where\n      // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n      // updating the value using `emitEvent: false`).\n      this._dirtyCheckNativeValue();\n      // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n      // present or not depends on a query which is prone to \"changed after checked\" errors.\n      this._dirtyCheckPlaceholder();\n    }\n    /** Focuses the input. */\n    focus(options) {\n      this._elementRef.nativeElement.focus(options);\n    }\n    /** Refreshes the error state of the input. */\n    updateErrorState() {\n      this._errorStateTracker.updateErrorState();\n    }\n    /** Callback for the cases where the focused state of the input changes. */\n    _focusChanged(isFocused) {\n      if (isFocused === this.focused) {\n        return;\n      }\n      if (!this._isNativeSelect && isFocused && this.disabled && this.disabledInteractive) {\n        const element = this._elementRef.nativeElement;\n        // Focusing an input that has text will cause all the text to be selected. Clear it since\n        // the user won't be able to change it. This is based on the internal implementation.\n        if (element.type === 'number') {\n          // setSelectionRange doesn't work on number inputs so it needs to be set briefly to text.\n          element.type = 'text';\n          element.setSelectionRange(0, 0);\n          element.type = 'number';\n        } else {\n          element.setSelectionRange(0, 0);\n        }\n      }\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n    _onInput() {\n      // This is a noop function and is used to let Angular know whenever the value changes.\n      // Angular will run a new change detection each time the `input` event has been dispatched.\n      // It's necessary that Angular recognizes the value change, because when floatingLabel\n      // is set to false and Angular forms aren't used, the placeholder won't recognize the\n      // value changes and will not disappear.\n      // Listening to the input event wouldn't be necessary when the input is using the\n      // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /** Does some manual dirty checking on the native input `value` property. */\n    _dirtyCheckNativeValue() {\n      const newValue = this._elementRef.nativeElement.value;\n      if (this._previousNativeValue !== newValue) {\n        this._previousNativeValue = newValue;\n        this.stateChanges.next();\n      }\n    }\n    /** Does some manual dirty checking on the native input `placeholder` attribute. */\n    _dirtyCheckPlaceholder() {\n      const placeholder = this._getPlaceholder();\n      if (placeholder !== this._previousPlaceholder) {\n        const element = this._elementRef.nativeElement;\n        this._previousPlaceholder = placeholder;\n        placeholder ? element.setAttribute('placeholder', placeholder) : element.removeAttribute('placeholder');\n      }\n    }\n    /** Gets the current placeholder of the form field. */\n    _getPlaceholder() {\n      return this.placeholder || null;\n    }\n    /** Make sure the input is a supported type. */\n    _validateType() {\n      if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatInputUnsupportedTypeError(this._type);\n      }\n    }\n    /** Checks whether the input type is one of the types that are never empty. */\n    _isNeverEmpty() {\n      return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /** Checks whether the input is invalid based on the native validation. */\n    _isBadInput() {\n      // The `validity` property won't be present on platform-server.\n      let validity = this._elementRef.nativeElement.validity;\n      return validity && validity.badInput;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get empty() {\n      return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat() {\n      if (this._isNativeSelect) {\n        // For a single-selection `<select>`, the label should float when the selected option has\n        // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n        // overlapping the label with the options.\n        const selectElement = this._elementRef.nativeElement;\n        const firstOption = selectElement.options[0];\n        // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n        // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n        return this.focused || selectElement.multiple || !this.empty || !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n      } else {\n        return this.focused && !this.disabled || !this.empty;\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids) {\n      const element = this._elementRef.nativeElement;\n      const existingDescribedBy = element.getAttribute('aria-describedby');\n      let toAssign;\n      // In some cases there might be some `aria-describedby` IDs that were assigned directly,\n      // like by the `AriaDescriber` (see #30011). Attempt to preserve them by taking the previous\n      // attribute value and filtering out the IDs that came from the previous `setDescribedByIds`\n      // call. Note the `|| ids` here allows us to avoid duplicating IDs on the first render.\n      if (existingDescribedBy) {\n        const exclude = this._formFieldDescribedBy || ids;\n        toAssign = ids.concat(existingDescribedBy.split(' ').filter(id => id && !exclude.includes(id)));\n      } else {\n        toAssign = ids;\n      }\n      this._formFieldDescribedBy = ids;\n      if (toAssign.length) {\n        element.setAttribute('aria-describedby', toAssign.join(' '));\n      } else {\n        element.removeAttribute('aria-describedby');\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick() {\n      // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n      // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n      // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n      if (!this.focused) {\n        this.focus();\n      }\n    }\n    /** Whether the form control is a native select that is displayed inline. */\n    _isInlineSelect() {\n      const element = this._elementRef.nativeElement;\n      return this._isNativeSelect && (element.multiple || element.size > 1);\n    }\n    _iOSKeyupListener = event => {\n      const el = event.target;\n      // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n      // indicate different things. If the value is 0, it means that the caret is at the start\n      // of the input, whereas a value of `null` means that the input doesn't support\n      // manipulating the selection range. Inputs that don't support setting the selection range\n      // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n      // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n      if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n        // Note: Just setting `0, 0` doesn't fix the issue. Setting\n        // `1, 1` fixes it for the first time that you type text and\n        // then hold delete. Toggling to `1, 1` and then back to\n        // `0, 0` seems to completely fix it.\n        el.setSelectionRange(1, 1);\n        el.setSelectionRange(0, 0);\n      }\n    };\n    _webkitBlinkWheelListener = () => {\n      // This is a noop function and is used to enable mouse wheel input\n      // on number inputs\n      // on blink and webkit browsers.\n    };\n    /**\n     * In blink and webkit browsers a focused number input does not increment or decrement its value\n     * on mouse wheel interaction unless a wheel event listener is attached to it or one of its\n     * ancestors or a passive wheel listener is attached somewhere in the DOM. For example: Hitting\n     * a tooltip once enables the mouse wheel input for all number inputs as long as it exists. In\n     * order to get reliable and intuitive behavior we apply a wheel event on our own thus making\n     * sure increment and decrement by mouse wheel works every time.\n     * @docs-private\n     */\n    _ensureWheelDefaultBehavior() {\n      this._cleanupWebkitWheel?.();\n      if (this._type === 'number' && (this._platform.BLINK || this._platform.WEBKIT)) {\n        this._cleanupWebkitWheel = this._renderer.listen(this._elementRef.nativeElement, 'wheel', this._webkitBlinkWheelListener);\n      }\n    }\n    /** Gets the value to set on the `readonly` attribute. */\n    _getReadonlyAttribute() {\n      if (this._isNativeSelect) {\n        return null;\n      }\n      if (this.readonly || this.disabled && this.disabledInteractive) {\n        return 'true';\n      }\n      return null;\n    }\n    static ɵfac = function MatInput_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatInput)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatInput,\n      selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]],\n      hostAttrs: [1, \"mat-mdc-input-element\"],\n      hostVars: 21,\n      hostBindings: function MatInput_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"focus\", function MatInput_focus_HostBindingHandler() {\n            return ctx._focusChanged(true);\n          })(\"blur\", function MatInput_blur_HostBindingHandler() {\n            return ctx._focusChanged(false);\n          })(\"input\", function MatInput_input_HostBindingHandler() {\n            return ctx._onInput();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.id)(\"disabled\", ctx.disabled && !ctx.disabledInteractive)(\"required\", ctx.required);\n          i0.ɵɵattribute(\"name\", ctx.name || null)(\"readonly\", ctx._getReadonlyAttribute())(\"aria-disabled\", ctx.disabled && ctx.disabledInteractive ? \"true\" : null)(\"aria-invalid\", ctx.empty && ctx.required ? null : ctx.errorState)(\"aria-required\", ctx.required)(\"id\", ctx.id);\n          i0.ɵɵclassProp(\"mat-input-server\", ctx._isServer)(\"mat-mdc-form-field-textarea-control\", ctx._isInFormField && ctx._isTextarea)(\"mat-mdc-form-field-input-control\", ctx._isInFormField)(\"mat-mdc-input-disabled-interactive\", ctx.disabledInteractive)(\"mdc-text-field__input\", ctx._isInFormField)(\"mat-mdc-native-select-inline\", ctx._isInlineSelect());\n        }\n      },\n      inputs: {\n        disabled: \"disabled\",\n        id: \"id\",\n        placeholder: \"placeholder\",\n        name: \"name\",\n        required: \"required\",\n        type: \"type\",\n        errorStateMatcher: \"errorStateMatcher\",\n        userAriaDescribedBy: [0, \"aria-describedby\", \"userAriaDescribedBy\"],\n        value: \"value\",\n        readonly: \"readonly\",\n        disabledInteractive: [2, \"disabledInteractive\", \"disabledInteractive\", booleanAttribute]\n      },\n      exportAs: [\"matInput\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MatFormFieldControl,\n        useExisting: MatInput\n      }]), i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return MatInput;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatInputModule = /*#__PURE__*/(() => {\n  class MatInputModule {\n    static ɵfac = function MatInputModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatInputModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatInputModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [MatCommonModule, MatFormFieldModule, MatFormFieldModule, TextFieldModule, MatCommonModule]\n    });\n  }\n  return MatInputModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { MAT_INPUT_CONFIG, MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, getMatInputUnsupportedTypeError };","map":{"version":3,"names":["coerceBooleanProperty","Platform","getSupportedInputTypes","AutofillMonitor","TextFieldModule","i0","InjectionToken","inject","ElementRef","NgZone","Renderer2","isSignal","effect","booleanAttribute","Directive","Input","NgModule","_IdGenerator","NgControl","Validators","NgForm","FormGroupDirective","Subject","M","MAT_INPUT_VALUE_ACCESSOR","h","MAT_FORM_FIELD","k","MatFormFieldControl","b","MatError","j","MatFormField","c","MatHint","MatLabel","e","MatPrefix","g","MatSuffix","E","ErrorStateMatcher","_","_ErrorStateTracker","MatFormFieldModule","MatCommonModule","getMatInputUnsupportedTypeError","type","Error","MAT_INPUT_INVALID_TYPES","MAT_INPUT_CONFIG","MatInput","_elementRef","_platform","ngControl","optional","self","_autofillMonitor","_ngZone","_formField","_renderer","_uid","getId","_previousNativeValue","_inputValueAccessor","_signalBasedValueAccessor","_previousPlaceholder","_errorStateTracker","_config","_cleanupIosKeyup","_cleanupWebkitWheel","_formFieldDescribedBy","_isServer","_isNativeSelect","_isTextarea","_isInFormField","focused","stateChanges","controlType","autofilled","disabled","_disabled","value","next","id","_id","placeholder","name","required","_required","control","hasValidator","_type","prevType","_validateType","has","nativeElement","_ensureWheelDefaultBehavior","errorStateMatcher","matcher","userAriaDescribedBy","set","readonly","_readonly","disabledInteractive","errorState","_neverEmptyInputTypes","filter","t","constructor","parentForm","parentFormGroup","defaultErrorStateMatcher","accessor","element","nodeName","toLowerCase","IOS","runOutsideAngular","listen","_iOSKeyupListener","isBrowser","multiple","ngAfterViewInit","monitor","subscribe","event","isAutofilled","ngOnChanges","ngOnDestroy","complete","stopMonitoring","ngDoCheck","updateErrorState","_dirtyCheckNativeValue","_dirtyCheckPlaceholder","focus","options","_focusChanged","isFocused","setSelectionRange","_onInput","newValue","_getPlaceholder","setAttribute","removeAttribute","indexOf","ngDevMode","_isNeverEmpty","_isBadInput","validity","badInput","empty","shouldLabelFloat","selectElement","firstOption","selectedIndex","label","setDescribedByIds","ids","existingDescribedBy","getAttribute","toAssign","exclude","concat","split","includes","length","join","onContainerClick","_isInlineSelect","size","el","target","selectionStart","selectionEnd","_webkitBlinkWheelListener","BLINK","WEBKIT","_getReadonlyAttribute","ɵfac","MatInput_Factory","__ngFactoryType__","ɵdir","ɵɵdefineDirective","selectors","hostAttrs","hostVars","hostBindings","MatInput_HostBindings","rf","ctx","ɵɵlistener","MatInput_focus_HostBindingHandler","MatInput_blur_HostBindingHandler","MatInput_input_HostBindingHandler","ɵɵhostProperty","ɵɵattribute","ɵɵclassProp","inputs","exportAs","features","ɵɵProvidersFeature","provide","useExisting","ɵɵNgOnChangesFeature","MatInputModule","MatInputModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports"],"sources":["C:/Users/itay7/Desktop/Job Interview AI/Job Interview AI/node_modules/@angular/material/fesm2022/input.mjs"],"sourcesContent":["import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Platform, getSupportedInputTypes } from '@angular/cdk/platform';\nimport { AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, NgZone, Renderer2, isSignal, effect, booleanAttribute, Directive, Input, NgModule } from '@angular/core';\nimport { _IdGenerator } from '@angular/cdk/a11y';\nimport { NgControl, Validators, NgForm, FormGroupDirective } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport { M as MAT_INPUT_VALUE_ACCESSOR } from './input-value-accessor-D1GvPuqO.mjs';\nimport { h as MAT_FORM_FIELD, k as MatFormFieldControl } from './form-field-DqPi4knt.mjs';\nexport { b as MatError, j as MatFormField, c as MatHint, M as MatLabel, e as MatPrefix, g as MatSuffix } from './form-field-DqPi4knt.mjs';\nimport { E as ErrorStateMatcher } from './error-options-Dm2JJUbF.mjs';\nimport { _ as _ErrorStateTracker } from './error-state-Dtb1IHM-.mjs';\nimport { M as MatFormFieldModule } from './module-BXZhw7pQ.mjs';\nimport { M as MatCommonModule } from './common-module-WayjW0Pb.mjs';\nimport '@angular/cdk/bidi';\nimport '@angular/common';\nimport 'rxjs/operators';\nimport '@angular/cdk/observers/private';\nimport '@angular/cdk/observers';\n\n/** @docs-private */\nfunction getMatInputUnsupportedTypeError(type) {\n    return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n    'button',\n    'checkbox',\n    'file',\n    'hidden',\n    'image',\n    'radio',\n    'range',\n    'reset',\n    'submit',\n];\n/** Injection token that can be used to provide the default options for the input. */\nconst MAT_INPUT_CONFIG = new InjectionToken('MAT_INPUT_CONFIG');\nclass MatInput {\n    _elementRef = inject(ElementRef);\n    _platform = inject(Platform);\n    ngControl = inject(NgControl, { optional: true, self: true });\n    _autofillMonitor = inject(AutofillMonitor);\n    _ngZone = inject(NgZone);\n    _formField = inject(MAT_FORM_FIELD, { optional: true });\n    _renderer = inject(Renderer2);\n    _uid = inject(_IdGenerator).getId('mat-input-');\n    _previousNativeValue;\n    _inputValueAccessor;\n    _signalBasedValueAccessor;\n    _previousPlaceholder;\n    _errorStateTracker;\n    _config = inject(MAT_INPUT_CONFIG, { optional: true });\n    _cleanupIosKeyup;\n    _cleanupWebkitWheel;\n    /** `aria-describedby` IDs assigned by the form field. */\n    _formFieldDescribedBy;\n    /** Whether the component is being rendered on the server. */\n    _isServer;\n    /** Whether the component is a native html select. */\n    _isNativeSelect;\n    /** Whether the component is a textarea. */\n    _isTextarea;\n    /** Whether the input is inside of a form field. */\n    _isInFormField;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    focused = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    stateChanges = new Subject();\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    controlType = 'mat-input';\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    autofilled = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        // Browsers may not fire the blur event if the input is disabled too quickly.\n        // Reset from here to ensure that the element doesn't become stuck.\n        if (this.focused) {\n            this.focused = false;\n            this.stateChanges.next();\n        }\n    }\n    _disabled = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get id() {\n        return this._id;\n    }\n    set id(value) {\n        this._id = value || this._uid;\n    }\n    _id;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    placeholder;\n    /**\n     * Name of the input.\n     * @docs-private\n     */\n    name;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get required() {\n        return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;\n    }\n    set required(value) {\n        this._required = coerceBooleanProperty(value);\n    }\n    _required;\n    /** Input type of the element. */\n    get type() {\n        return this._type;\n    }\n    set type(value) {\n        const prevType = this._type;\n        this._type = value || 'text';\n        this._validateType();\n        // When using Angular inputs, developers are no longer able to set the properties on the native\n        // input element. To ensure that bindings for `type` work, we need to sync the setter\n        // with the native property. Textarea elements don't support the type property or attribute.\n        if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n            this._elementRef.nativeElement.type = this._type;\n        }\n        if (this._type !== prevType) {\n            this._ensureWheelDefaultBehavior();\n        }\n    }\n    _type = 'text';\n    /** An object used to control when error messages are shown. */\n    get errorStateMatcher() {\n        return this._errorStateTracker.matcher;\n    }\n    set errorStateMatcher(value) {\n        this._errorStateTracker.matcher = value;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    userAriaDescribedBy;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get value() {\n        return this._signalBasedValueAccessor\n            ? this._signalBasedValueAccessor.value()\n            : this._inputValueAccessor.value;\n    }\n    set value(value) {\n        if (value !== this.value) {\n            if (this._signalBasedValueAccessor) {\n                this._signalBasedValueAccessor.value.set(value);\n            }\n            else {\n                this._inputValueAccessor.value = value;\n            }\n            this.stateChanges.next();\n        }\n    }\n    /** Whether the element is readonly. */\n    get readonly() {\n        return this._readonly;\n    }\n    set readonly(value) {\n        this._readonly = coerceBooleanProperty(value);\n    }\n    _readonly = false;\n    /** Whether the input should remain interactive when it is disabled. */\n    disabledInteractive;\n    /** Whether the input is in an error state. */\n    get errorState() {\n        return this._errorStateTracker.errorState;\n    }\n    set errorState(value) {\n        this._errorStateTracker.errorState = value;\n    }\n    _neverEmptyInputTypes = [\n        'date',\n        'datetime',\n        'datetime-local',\n        'month',\n        'time',\n        'week',\n    ].filter(t => getSupportedInputTypes().has(t));\n    constructor() {\n        const parentForm = inject(NgForm, { optional: true });\n        const parentFormGroup = inject(FormGroupDirective, { optional: true });\n        const defaultErrorStateMatcher = inject(ErrorStateMatcher);\n        const accessor = inject(MAT_INPUT_VALUE_ACCESSOR, { optional: true, self: true });\n        const element = this._elementRef.nativeElement;\n        const nodeName = element.nodeName.toLowerCase();\n        if (accessor) {\n            if (isSignal(accessor.value)) {\n                this._signalBasedValueAccessor = accessor;\n            }\n            else {\n                this._inputValueAccessor = accessor;\n            }\n        }\n        else {\n            // If no input value accessor was explicitly specified, use the element as the input value\n            // accessor.\n            this._inputValueAccessor = element;\n        }\n        this._previousNativeValue = this.value;\n        // Force setter to be called in case id was not specified.\n        this.id = this.id;\n        // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n        // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n        // exists on iOS, we only bother to install the listener on iOS.\n        if (this._platform.IOS) {\n            this._ngZone.runOutsideAngular(() => {\n                this._cleanupIosKeyup = this._renderer.listen(element, 'keyup', this._iOSKeyupListener);\n            });\n        }\n        this._errorStateTracker = new _ErrorStateTracker(defaultErrorStateMatcher, this.ngControl, parentFormGroup, parentForm, this.stateChanges);\n        this._isServer = !this._platform.isBrowser;\n        this._isNativeSelect = nodeName === 'select';\n        this._isTextarea = nodeName === 'textarea';\n        this._isInFormField = !!this._formField;\n        this.disabledInteractive = this._config?.disabledInteractive || false;\n        if (this._isNativeSelect) {\n            this.controlType = element.multiple\n                ? 'mat-native-select-multiple'\n                : 'mat-native-select';\n        }\n        if (this._signalBasedValueAccessor) {\n            effect(() => {\n                // Read the value so the effect can register the dependency.\n                this._signalBasedValueAccessor.value();\n                this.stateChanges.next();\n            });\n        }\n    }\n    ngAfterViewInit() {\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n                this.autofilled = event.isAutofilled;\n                this.stateChanges.next();\n            });\n        }\n    }\n    ngOnChanges() {\n        this.stateChanges.next();\n    }\n    ngOnDestroy() {\n        this.stateChanges.complete();\n        if (this._platform.isBrowser) {\n            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n        }\n        this._cleanupIosKeyup?.();\n        this._cleanupWebkitWheel?.();\n    }\n    ngDoCheck() {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n            // Since the input isn't a `ControlValueAccessor`, we don't have a good way of knowing when\n            // the disabled state has changed. We can't use the `ngControl.statusChanges`, because it\n            // won't fire if the input is disabled with `emitEvents = false`, despite the input becoming\n            // disabled.\n            if (this.ngControl.disabled !== null && this.ngControl.disabled !== this.disabled) {\n                this.disabled = this.ngControl.disabled;\n                this.stateChanges.next();\n            }\n        }\n        // We need to dirty-check the native element's value, because there are some cases where\n        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n        // updating the value using `emitEvent: false`).\n        this._dirtyCheckNativeValue();\n        // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n        // present or not depends on a query which is prone to \"changed after checked\" errors.\n        this._dirtyCheckPlaceholder();\n    }\n    /** Focuses the input. */\n    focus(options) {\n        this._elementRef.nativeElement.focus(options);\n    }\n    /** Refreshes the error state of the input. */\n    updateErrorState() {\n        this._errorStateTracker.updateErrorState();\n    }\n    /** Callback for the cases where the focused state of the input changes. */\n    _focusChanged(isFocused) {\n        if (isFocused === this.focused) {\n            return;\n        }\n        if (!this._isNativeSelect && isFocused && this.disabled && this.disabledInteractive) {\n            const element = this._elementRef.nativeElement;\n            // Focusing an input that has text will cause all the text to be selected. Clear it since\n            // the user won't be able to change it. This is based on the internal implementation.\n            if (element.type === 'number') {\n                // setSelectionRange doesn't work on number inputs so it needs to be set briefly to text.\n                element.type = 'text';\n                element.setSelectionRange(0, 0);\n                element.type = 'number';\n            }\n            else {\n                element.setSelectionRange(0, 0);\n            }\n        }\n        this.focused = isFocused;\n        this.stateChanges.next();\n    }\n    _onInput() {\n        // This is a noop function and is used to let Angular know whenever the value changes.\n        // Angular will run a new change detection each time the `input` event has been dispatched.\n        // It's necessary that Angular recognizes the value change, because when floatingLabel\n        // is set to false and Angular forms aren't used, the placeholder won't recognize the\n        // value changes and will not disappear.\n        // Listening to the input event wouldn't be necessary when the input is using the\n        // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /** Does some manual dirty checking on the native input `value` property. */\n    _dirtyCheckNativeValue() {\n        const newValue = this._elementRef.nativeElement.value;\n        if (this._previousNativeValue !== newValue) {\n            this._previousNativeValue = newValue;\n            this.stateChanges.next();\n        }\n    }\n    /** Does some manual dirty checking on the native input `placeholder` attribute. */\n    _dirtyCheckPlaceholder() {\n        const placeholder = this._getPlaceholder();\n        if (placeholder !== this._previousPlaceholder) {\n            const element = this._elementRef.nativeElement;\n            this._previousPlaceholder = placeholder;\n            placeholder\n                ? element.setAttribute('placeholder', placeholder)\n                : element.removeAttribute('placeholder');\n        }\n    }\n    /** Gets the current placeholder of the form field. */\n    _getPlaceholder() {\n        return this.placeholder || null;\n    }\n    /** Make sure the input is a supported type. */\n    _validateType() {\n        if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatInputUnsupportedTypeError(this._type);\n        }\n    }\n    /** Checks whether the input type is one of the types that are never empty. */\n    _isNeverEmpty() {\n        return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /** Checks whether the input is invalid based on the native validation. */\n    _isBadInput() {\n        // The `validity` property won't be present on platform-server.\n        let validity = this._elementRef.nativeElement.validity;\n        return validity && validity.badInput;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get empty() {\n        return (!this._isNeverEmpty() &&\n            !this._elementRef.nativeElement.value &&\n            !this._isBadInput() &&\n            !this.autofilled);\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat() {\n        if (this._isNativeSelect) {\n            // For a single-selection `<select>`, the label should float when the selected option has\n            // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n            // overlapping the label with the options.\n            const selectElement = this._elementRef.nativeElement;\n            const firstOption = selectElement.options[0];\n            // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n            // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n            return (this.focused ||\n                selectElement.multiple ||\n                !this.empty ||\n                !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label));\n        }\n        else {\n            return (this.focused && !this.disabled) || !this.empty;\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    setDescribedByIds(ids) {\n        const element = this._elementRef.nativeElement;\n        const existingDescribedBy = element.getAttribute('aria-describedby');\n        let toAssign;\n        // In some cases there might be some `aria-describedby` IDs that were assigned directly,\n        // like by the `AriaDescriber` (see #30011). Attempt to preserve them by taking the previous\n        // attribute value and filtering out the IDs that came from the previous `setDescribedByIds`\n        // call. Note the `|| ids` here allows us to avoid duplicating IDs on the first render.\n        if (existingDescribedBy) {\n            const exclude = this._formFieldDescribedBy || ids;\n            toAssign = ids.concat(existingDescribedBy.split(' ').filter(id => id && !exclude.includes(id)));\n        }\n        else {\n            toAssign = ids;\n        }\n        this._formFieldDescribedBy = ids;\n        if (toAssign.length) {\n            element.setAttribute('aria-describedby', toAssign.join(' '));\n        }\n        else {\n            element.removeAttribute('aria-describedby');\n        }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick() {\n        // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n        // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n        // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n        if (!this.focused) {\n            this.focus();\n        }\n    }\n    /** Whether the form control is a native select that is displayed inline. */\n    _isInlineSelect() {\n        const element = this._elementRef.nativeElement;\n        return this._isNativeSelect && (element.multiple || element.size > 1);\n    }\n    _iOSKeyupListener = (event) => {\n        const el = event.target;\n        // Note: We specifically check for 0, rather than `!el.selectionStart`, because the two\n        // indicate different things. If the value is 0, it means that the caret is at the start\n        // of the input, whereas a value of `null` means that the input doesn't support\n        // manipulating the selection range. Inputs that don't support setting the selection range\n        // will throw an error so we want to avoid calling `setSelectionRange` on them. See:\n        // https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n        if (!el.value && el.selectionStart === 0 && el.selectionEnd === 0) {\n            // Note: Just setting `0, 0` doesn't fix the issue. Setting\n            // `1, 1` fixes it for the first time that you type text and\n            // then hold delete. Toggling to `1, 1` and then back to\n            // `0, 0` seems to completely fix it.\n            el.setSelectionRange(1, 1);\n            el.setSelectionRange(0, 0);\n        }\n    };\n    _webkitBlinkWheelListener = () => {\n        // This is a noop function and is used to enable mouse wheel input\n        // on number inputs\n        // on blink and webkit browsers.\n    };\n    /**\n     * In blink and webkit browsers a focused number input does not increment or decrement its value\n     * on mouse wheel interaction unless a wheel event listener is attached to it or one of its\n     * ancestors or a passive wheel listener is attached somewhere in the DOM. For example: Hitting\n     * a tooltip once enables the mouse wheel input for all number inputs as long as it exists. In\n     * order to get reliable and intuitive behavior we apply a wheel event on our own thus making\n     * sure increment and decrement by mouse wheel works every time.\n     * @docs-private\n     */\n    _ensureWheelDefaultBehavior() {\n        this._cleanupWebkitWheel?.();\n        if (this._type === 'number' && (this._platform.BLINK || this._platform.WEBKIT)) {\n            this._cleanupWebkitWheel = this._renderer.listen(this._elementRef.nativeElement, 'wheel', this._webkitBlinkWheelListener);\n        }\n    }\n    /** Gets the value to set on the `readonly` attribute. */\n    _getReadonlyAttribute() {\n        if (this._isNativeSelect) {\n            return null;\n        }\n        if (this.readonly || (this.disabled && this.disabledInteractive)) {\n            return 'true';\n        }\n        return null;\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatInput, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"16.1.0\", version: \"19.2.6\", type: MatInput, isStandalone: true, selector: \"input[matInput], textarea[matInput], select[matNativeControl],\\n      input[matNativeControl], textarea[matNativeControl]\", inputs: { disabled: \"disabled\", id: \"id\", placeholder: \"placeholder\", name: \"name\", required: \"required\", type: \"type\", errorStateMatcher: \"errorStateMatcher\", userAriaDescribedBy: [\"aria-describedby\", \"userAriaDescribedBy\"], value: \"value\", readonly: \"readonly\", disabledInteractive: [\"disabledInteractive\", \"disabledInteractive\", booleanAttribute] }, host: { listeners: { \"focus\": \"_focusChanged(true)\", \"blur\": \"_focusChanged(false)\", \"input\": \"_onInput()\" }, properties: { \"class.mat-input-server\": \"_isServer\", \"class.mat-mdc-form-field-textarea-control\": \"_isInFormField && _isTextarea\", \"class.mat-mdc-form-field-input-control\": \"_isInFormField\", \"class.mat-mdc-input-disabled-interactive\": \"disabledInteractive\", \"class.mdc-text-field__input\": \"_isInFormField\", \"class.mat-mdc-native-select-inline\": \"_isInlineSelect()\", \"id\": \"id\", \"disabled\": \"disabled && !disabledInteractive\", \"required\": \"required\", \"attr.name\": \"name || null\", \"attr.readonly\": \"_getReadonlyAttribute()\", \"attr.aria-disabled\": \"disabled && disabledInteractive ? \\\"true\\\" : null\", \"attr.aria-invalid\": \"(empty && required) ? null : errorState\", \"attr.aria-required\": \"required\", \"attr.id\": \"id\" }, classAttribute: \"mat-mdc-input-element\" }, providers: [{ provide: MatFormFieldControl, useExisting: MatInput }], exportAs: [\"matInput\"], usesOnChanges: true, ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatInput, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n                    exportAs: 'matInput',\n                    host: {\n                        'class': 'mat-mdc-input-element',\n                        // The BaseMatInput parent class adds `mat-input-element`, `mat-form-field-control` and\n                        // `mat-form-field-autofill-control` to the CSS class list, but this should not be added for\n                        // this MDC equivalent input.\n                        '[class.mat-input-server]': '_isServer',\n                        '[class.mat-mdc-form-field-textarea-control]': '_isInFormField && _isTextarea',\n                        '[class.mat-mdc-form-field-input-control]': '_isInFormField',\n                        '[class.mat-mdc-input-disabled-interactive]': 'disabledInteractive',\n                        '[class.mdc-text-field__input]': '_isInFormField',\n                        '[class.mat-mdc-native-select-inline]': '_isInlineSelect()',\n                        // Native input properties that are overwritten by Angular inputs need to be synced with\n                        // the native input element. Otherwise property bindings for those don't work.\n                        '[id]': 'id',\n                        '[disabled]': 'disabled && !disabledInteractive',\n                        '[required]': 'required',\n                        '[attr.name]': 'name || null',\n                        '[attr.readonly]': '_getReadonlyAttribute()',\n                        '[attr.aria-disabled]': 'disabled && disabledInteractive ? \"true\" : null',\n                        // Only mark the input as invalid for assistive technology if it has a value since the\n                        // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n                        '[attr.aria-invalid]': '(empty && required) ? null : errorState',\n                        '[attr.aria-required]': 'required',\n                        // Native input properties that are overwritten by Angular inputs need to be synced with\n                        // the native input element. Otherwise property bindings for those don't work.\n                        '[attr.id]': 'id',\n                        '(focus)': '_focusChanged(true)',\n                        '(blur)': '_focusChanged(false)',\n                        '(input)': '_onInput()',\n                    },\n                    providers: [{ provide: MatFormFieldControl, useExisting: MatInput }],\n                }]\n        }], ctorParameters: () => [], propDecorators: { disabled: [{\n                type: Input\n            }], id: [{\n                type: Input\n            }], placeholder: [{\n                type: Input\n            }], name: [{\n                type: Input\n            }], required: [{\n                type: Input\n            }], type: [{\n                type: Input\n            }], errorStateMatcher: [{\n                type: Input\n            }], userAriaDescribedBy: [{\n                type: Input,\n                args: ['aria-describedby']\n            }], value: [{\n                type: Input\n            }], readonly: [{\n                type: Input\n            }], disabledInteractive: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }] } });\n\nclass MatInputModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatInputModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"19.2.6\", ngImport: i0, type: MatInputModule, imports: [MatCommonModule, MatFormFieldModule, MatInput], exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatInputModule, imports: [MatCommonModule, MatFormFieldModule, MatFormFieldModule, TextFieldModule, MatCommonModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatInputModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule, MatFormFieldModule, MatInput],\n                    exports: [MatInput, MatFormFieldModule, TextFieldModule, MatCommonModule],\n                }]\n        }] });\n\nexport { MAT_INPUT_CONFIG, MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, getMatInputUnsupportedTypeError };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}